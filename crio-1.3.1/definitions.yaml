controls:
  id: "20.04"
  description: "CIS CRI-O Community Edition Benchmark"
  groups:
  - id: 1
    description: "Host Configuration"
    checks:
    - id: 1.1
      description: "Linux Hosts Specific Configuration"
      checks:
      - id: 1.1.1
        description: "Ensure a separate partition for containers has been created (Automated)"
        audit: "grep '$crio-storage\\s' /proc/mounts"
        tests:
          test_items:
          - flag: "$crio-storage"
            set: true
        remediation: "For new installations, you should create a separate partition for the $crio-storage mount point.\nFor systems which have already been installed, \nyou should use the Logical Volume Manager (LVM)\nwithin Linux to create a new partition.\n"
        scored: true

      - id: 1.1.2
        description: "Ensure only trusted users are allowed to control CRI-O daemon (Automated)"
        audit: "getent group crio"
        type: manual
        remediation: "You should remove any untrusted users from the crio group. \nAdditionally, you should not create a mapping of sensitive directories from the host to container volumes.\"\n"
        scored: true

      - id: 1.1.3
        description: "Ensure auditing is configured for the CRI-O daemon (Automated)"
        audit: "auditctl -l | grep /usr/bin/crio"
        tests:
          test_items:
          - flag: "/usr/bin/crio"
            set: true
        remediation: "You should add rules for the CRI-O daemon. \nFor example: \nAdd the line below to the /etc/audit/audit.rules file: \n-w /usr/bin/crio -k crio\nThen, restart the audit daemon using the following command \nsystemctl restart auditd\n"
        scored: true

      - id: 1.1.4
        description: "Ensure auditing is configured for CRI-O files and directories - /run/containerd (Automated)"
        audit: "auditctl -l | grep /run/crio"
        tests:
          test_items:
          - flag: "/run/crio"
            set: true
        remediation: "You should add a rule for the $crio-storage directory. \nFor example, \nAdd the line as below to the /etc/audit/audit.rules file:\n-a exit,always -F path=/run/crio -F perm=war -k crio\nThen restart the audit daemon. For example, \nsystemctl restart auditd\n"
        scored: true

      - id: 1.1.5
        description: "Ensure auditing is configured for CRI-O files and directories - $crio-storage (Automated)"
        audit: "auditctl -l | grep $crio-storage"
        tests:
          test_items:
          - flag: "$crio-storage"
            set: true
        remediation: "You should add a rule for the $crio-storage directory. \nFor example, \nAdd the line as below to the /etc/audit/audit.rules file:\n-a exit,always -F path=$crio-storage -F perm=war -k crio\nThen restart the audit daemon. For example, \nsystemctl restart auditd\n"
        scored: true

      - id: 1.1.6
        description: "Ensure auditing is configured for CRI-O files and directories - /etc/crio (Automated)"
        audit: "auditctl -l | grep /etc/crio"
        tests:
          test_items:
          - flag: "/etc/crio"
            set: true
        remediation: "You should add a rule for the /etc/crio directory.\nFor example: \nAdd the line below to the /etc/audit/audit.rules file:\n-w /etc/crio -k crio\nThen restart the audit daemon. For example: \nsystemctl restart auditd\n"
        scored: true

      - id: 1.1.7
        description: "Ensure auditing is configured for CRI-O files and directories - crio.service (Automated)"
        audit: |
          test_file=$(systemctl show -p FragmentPath crio.service | awk -F "=" '{print $2}')
          if test -f "$test_file"; then
            auditctl -l | grep $test_file
          fi
        tests:
          test_items:
          - flag: "crio.service"
            set: true
        remediation: "If the file exists, a rule for it should be added. \nFor example: \nAdd the line as below in /etc/audit/audit.rules file:\n-w /usr/lib/systemd/system/crio.service -k crio\nThen restart the audit daemon. \nFor example:\nsystemctl restart auditd\n"
        scored: true

      - id: 1.1.8
        description: "Ensure auditing is configured for CRI-O files and directories - crio.sock (Automated)"
        audit: |
          test_file=$(grep 'crio.sock' /etc/crio/crio.conf | awk -F "\"" '{print $2}')
          if test -S "$test_file"; then
            auditctl -l | grep $test_file
          fi
        tests:
          test_items:
          - flag: "crio.sock"
            set: true
        remediation: "If the file exists, you should add a rule for it. \nFor example: \nAdd the line below to the /etc/audit/audit.rules file:\n-w /run/crio/crio.sock -k crio\nThen restart the audit daemon. \nFor example:\nsystemctl restart auditd\n"
        scored: true

      - id: 1.1.9
        description: "Ensure auditing is configured for CRI-O files and directories - crio.socket (Automated)"
        audit: |
          socket_file=$(grep '^ListenStream' $(systemctl show -p FragmentPath crio.socket | awk -F"=" '{print $2}')| awk -F "=" '{print $2}')
          if test -S "$socket_file"; then
            auditctl -l | grep $socket_file
          fi
        tests:
          test_items:
          - flag: "crio.sock"
            set: true
        remediation: "If the file exists, you should add a rule for it. \nFor example: \nAdd the line below to the /etc/audit/audit.rules file:\n-w $socket_file -k crio\nThen restart the audit daemon. \nFor example:\nsystemctl restart auditd\n"
        scored: true

      - id: 1.1.10
        description: "Ensure auditing is configured for CRI-O files and directories - /etc/default/crio (Automated)"
        audit: "auditctl -l | grep /etc/default/crio"
        tests:
          test_items:
          - flag: "/etc/default/crio"
            set: true
        remediation: "You should add a rule for the /etc/default/crio directory.\nFor example: \nAdd the line below to the /etc/audit/audit.rules file:\n-w /etc/default/crio -k crio\nThen restart the audit daemon. For example: \nsystemctl restart auditd\n"
        scored: true

      - id: 1.1.11
        description: "Ensure auditing is configured for CRI-O files and directories - $crio-config-file (Automated)"
        audit: "auditctl -l | grep $crio-config-file"
        tests:
          test_items:
          - flag: "$crio-config-file"
            set: true
        remediation: "You should add a rule for the $crio-config-file directory.\nFor example: \nAdd the line below to the /etc/audit/audit.rules file:\n-w $crio-config-file -k crio\nThen restart the audit daemon. For example: \nsystemctl restart auditd\n"
        scored: true

      - id: 1.1.12
        description: "Ensure auditing is configured for CRI-O files and directories - /etc/crio/config.toml (Automated)"
        audit: "auditctl -l | grep /etc/crio/config.toml"
        tests:
          test_items:
          - flag: "/etc/crio/config.toml"
            set: true
        remediation: "You should add a rule for the /etc/crio/config.toml directory.\nFor example: \nAdd the line below to the /etc/audit/audit.rules file:\n-w /etc/crio/config.toml -k crio\nThen restart the audit daemon. For example: \nsystemctl restart auditd\n"
        scored: true

      - id: 1.1.13
        description: "Ensure auditing is configured for CRI-O files and directories - /etc/sysconfig/crio (Automated)"
        audit: "auditctl -l | grep /etc/sysconfig/crio"
        tests:
          test_items:
          - flag: "/etc/sysconfig/crio"
            set: true
        remediation: "You should add a rule for the /etc/sysconfig/crio file. \nFor example: Add the line below to the /etc/audit/audit.rules file:\n-w /etc/sysconfig/crio -k crio\nThen restart the audit daemon. For example: \nservice auditd restart\n"
        scored: true

      - id: 1.1.14
        description: "Ensure auditing is configured for CRI-O files and directories - /usr/bin/containerd (Automated)"
        audit: "auditctl -l | grep /usr/bin/containerd"
        tests:
          test_items:
          - flag: "/usr/bin/containerd"
            set: true
        remediation: "You should add a rule for the /usr/bin/containerd file. \nFor example: \nAdd the line below to the /etc/audit/audit.rules file:\n-w /usr/bin/containerd -k crio\nThen restart the audit daemon. \nFor example: \nservice auditd restart\n"
        scored: true

      - id: 1.1.15
        description: "Ensure auditing is configured for CRI-O files and directories - /usr/bin/containerd-shim (Automated)"
        audit: "auditctl -l | grep /usr/bin/containerd-shim"
        tests:
          test_items:
          - flag: "/usr/bin/containerd-shim"
            set: true
        remediation: "You should add a rule for the /usr/bin/containerd-shim file. \nFor example: \nAdd the line below to the /etc/audit/audit.rules file:\n-w /usr/bin/containerd-shim -k crio\nThen restart the audit daemon. \nFor example: \nservice auditd restart\n"
        scored: true

      - id: 1.1.16
        description: "Ensure auditing is configured for CRI-O files and directories - /usr/bin/containerd-shim-runc-v1 (Automated)"
        audit: "auditctl -l | grep /usr/bin/containerd-shim-runc-v1"
        tests:
          test_items:
          - flag: "/usr/bin/containerd-shim-runc-v1"
            set: true
        remediation: "You should add a rule for the /usr/bin/containerd-shim-runc-v1 file. \nFor example: \nAdd the line below to the /etc/audit/audit.rules file:\n-w /usr/bin/containerd-shim-runc-v1 -k crio\nThen restart the audit daemon. \nFor example: \nservice auditd restart\n"
        scored: true

      - id: 1.1.17
        description: "Ensure auditing is configured for CRI-O files and directories - /usr/bin/containerd-shim-runc-v2 (Automated)"
        audit: "auditctl -l | grep /usr/bin/containerd-shim-runc-v2"
        tests:
          test_items:
          - flag: "/usr/bin/containerd-shim-runc-v2"
            set: true
        remediation: "You should add a rule for the /usr/bin/containerd-shim-runc-v2 file. \nFor example: \nAdd the line below to the /etc/audit/audit.rules file:\n-w /usr/bin/containerd-shim-runc-v2 -k crio\nThen restart the audit daemon. \nFor example: \nservice auditd restart\n"
        scored: true

      - id: 1.1.18
        description: "Ensure auditing is configured for CRI-O files and directories - /usr/bin/runc (Automated)"
        audit: "auditctl -l | grep /usr/bin/runc"
        tests:
          test_items:
          - flag: "/usr/bin/runc"
            set: true
        remediation: "You should add a rule for /usr/bin/runc file. \nFor example:\nAdd the line below to the /etc/audit/audit.rules file: \n-w /usr/bin/runc -k crio\nThen restart the audit daemon. \nFor example: \nservice auditd restart\n"
        scored: true

    - id: 1.2
      description: "General Configuration"
      checks:
      - id: 1.2.1
        description: "Ensure the container host has been Hardened (Manual)"
        type: manual
        audit: |
          Ensure that the host-specific security guidelines are followed.
          Ask the system administrators which security benchmark the current
          host system should currently be compliant with and check that security
          standards associated with this standard are currently in place.
        remediation: |
          You may consider various CIS Security Benchmarks for your container host.
          If you have other security guidelines or regulatory requirements
          to adhere to, please follow them as suitable in your environment.
        scored: false
      - id: 1.2.2
        description: "Ensure that the version of CRI-O is up to date (Manual)"
        type: manual
        audit: "crio version"
        remediation: |
          You should monitor versions of CRI-O releases and make sure
          your software is updated as required.
        scored: false

  - id: 2
    description: "CRI-O daemon configuration"
    checks:
    - id: 2.1
      description: "Run the CRI-O daemon as a non-root user, if possible (Manual)"
      audit: "ps -fe | grep 'crio'"
      type: manual
      remediation: |
        Follow the current CRI-O documentation on how to install the CRI-O daemon as a non-root user.
      scored: true

    - id: 2.2
      description: "Ensure network traffic is restricted between containers on the default bridge (Automated)"
      audit: "crio config | grep 'bridge_network'"
      tests:
        test_items:
        - flag: "bridge_network.enable_icc:true"
          set: false
      remediation: |
        Edit the CRI-O daemon configuration file to ensure that icc is disabled. It should include
        the following setting
        "icc": false
        Alternatively, run the CRI-O daemon directly and pass --icc=false as an argument.
        For example,
        crio --icc=false
        Alternatively, you can follow the CRI-O documentation and create a custom network and
        only join containers that need to communicate to that custom network. The --icc
        parameter only applies to the default CRI-O bridge, if custom networks are used then the
        approach of segmenting networks should be adopted instead.
        In order for this control to be fully effective, all containers connected to the cni0 bridge
        should drop the NET_RAW capability, otherwise, a compromised container could use raw
        Ethernet packets to communicate with other containers despite this restriction.
      scored: true

    - id: 2.3
      description: "Ensure the logging level is set to 'info' (Automated)"
      audit: |
        ps -ef | grep crio
        cat $crio-config-file
      tests:
        bin_op: or
        test_items:
        - flag: "--log-level"
          set: false
        - flag: "--log-level"
          compare:
            op: eq
            value: "info"
          set: true
        - flag: "\"log-level\""
          compare:
            op: eq
            value: "info"
          set: true
      remediation: |
        Ensure that the CRI-O daemon configuration file has the following configuration included
        "log-level": "info"
        Alternatively, run the CRI-O daemon as below:
        crio --log-level="info"
      scored: true

    - id: 2.4
      description: "Ensure CRI-O is allowed to make changes to iptables (Automated)"
      audit: |
        ps -ef | grep crio
        cat $crio-config-file
      tests:
        bin_op: or
        test_items:
        - flag: "--iptables"
          set: false
        - flag: "--iptables"
          compare:
            op: eq
            value: true
          set: true
        - flag: "\"iptables\""
          compare:
            op: eq
            value: "true"
          set: true
      remediation: |
        Do not run the CRI-O daemon with --iptables=false parameter. For example, do not
        start the CRI-O daemon as below:
        crio --iptables=false
      scored: true

    - id: 2.5
      description: "Ensure insecure registries are not used (Automated)"
      audit: "crio config | grep 'insecure_registries'"
      type: manual
      remediation: |
        You should ensure that no insecure registries are in use.
      scored: true

    - id: 2.6
      description: "Ensure overlay storage driver is not used (Automated)"
      audit: "crio config | grep 'storage_driver'"
      tests:
        test_items:
        - flag: "overlay"
          set: false
      remediation: |
        Do not explicitly use overlay as a storage driver.
        For example, do not start the CRI-O daemon as below:
        crio --storage-driver overlay
      scored: true

    - id: 2.7
      description: "Ensure TLS authentication for CRI-O daemon is configured (Automated)"
      audit: |
        ps -ef | grep crio
        grep tls $crio-config-file | tr -d ","
      tests:
        bin_op: and
        test_items:
        - flag: "tlsverify"
          compare:
            op: eq
            value: true
          set: true
        - flag: "tlscacert"
          compare:
            op: noteq
            value: '""'
          set: true
        - flag: "tlscert"
          compare:
            op: noteq
            value: '""'
          set: true
        - flag: "tlskey"
          compare:
            op: noteq
            value: '""'
          set: true
      remediation: |
        Follow the steps mentioned in the CRI-O documentation or other references.
      scored: true

    - id: 2.8
      description: "Ensure the default ulimit is configured appropriately (Manual)"
      audit: "ps -ef | grep crio"
      type: manual
      tests:
        test_items:
        - flag: "--default-ulimit"
          set: true
      remediation: |
        Run the CRI-O in daemon mode and pass --default-ulimit as an argument with respective
        ulimits as appropriate in your environment.
        For example,
        crio --default-ulimit nproc=1024:2048 --default-ulimit nofile=100:200
      scored: false

    - id: 2.9
      description: "Enable user namespace support (Automated)"
      audit: "crio info --format '{{ .SecurityOptions }}'"
      tests:
        test_items:
        - flag: "userns"
          compare:
            op: has
            value: "userns"
          set: true
      remediation: |
        Please consult the CRI-O documentation for various ways in which this can be configured
        depending upon your requirements. Your steps might also vary based on the platform - For
        example, on Red Hat, sub-UIDs and sub-GIDs mapping creation do not work automatically.
        You might have to create your own mapping.
        The high-level steps are as below:
        Step 1: Ensure that the files /etc/subuid and /etc/subgid exist.
        touch /etc/subuid /etc/subgid
        Step 2: Start the CRI-O daemon with --userns-remap flag
        crio --userns-remap=default
      scored: true

    - id: 2.10
      description: "Ensure the default cgroup usage has been confirmed (Automated)"
      audit: |
        ps -ef | grep crio
        grep cgroup-parent $crio-config-file
      tests:
        bin_op: or
        test_items:
        - flag: "cgroup-parent"
          set: false
        - flag: "cgroup-parent"
          compare:
            op: nothave
            value: "/crio"
          set: true
      remediation: |
        The default setting is in line with good security practice and can be left in situ. If you wish
        to specifically set a non-default cgroup, pass the --cgroup-parent parameter to the CRI-O
        daemon when starting it.
        For example,
        crio --cgroup-parent=/foobar
      scored: true

    - id: 2.11
      description: "Ensure base device size is not changed until needed (Automated)"
      audit: |
        ps -ef | grep crio
        grep storage-opt $crio-config-file
      tests:
        bin_op: or
        test_items:
        - flag: "storage-opt"
          set: false
        - flag: "storage-opt"
          compare:
            op: eq
            value: ""
          set: true
      remediation: |
        Do not set --storage-opt dm.basesize until needed.
      scored: true

    - id: 2.12
      description: "Ensure that authorization for CRI-O client commands is enabled (Automated)"
      audit: |
        ps -ef | grep crio
        grep authorization-plugin $crio-config-file | tr -d ","
      tests:
        bin_op: or
        test_items:
        - flag: "--authorization-plugin"
          set: true
        - flag: 'authorization-plugins'
          compare:
            op: noteq
            value: "[]"
          set: true
      remediation: |
        Step 1: Install/Create an authorization plugin.
        Step 2: Configure the authorization policy as desired.
        Step 3: Start the CRI-O daemon as below:
        crio --authorization-plugin=<PLUGIN_ID>
      scored: true

    - id: 2.13
      description: "Ensure centralized and remote logging is configured (Automated)"
      audit: |
        ps -ef | grep crio
        grep log-driver $crio-config-file | tr -d ","
      tests:
        bin_op: or
        test_items:
        - flag: "--log-driver"
          set: true
        - flag: "log-driver"
          compare:
            op: noteq
            value: '""'
          set: true
      remediation: |
        Step 1: Setup the desired log driver by following its documentation.
        Step 2: Start the CRI-O daemon with that logging driver.
        For example,
        crio --log-driver=syslog --log-opt syslog-address=tcp://192.xxx.xxx.xxx
      scored: true

    - id: 2.14
      description: "Ensure containers are restricted from acquiring new privileges (Automated)"
      audit: |
        ps -ef | grep crio
        grep no-new-privileges $crio-config-file | tr -d ","
      tests:
        test_items:
        - flag: "no-new-privileges"
          compare:
            op: eq
            value: "true"
          set: true
      remediation: |
        You should run the CRI-O daemon as below:
        crio --no-new-privileges
      scored: true

    - id: 2.15
      description: "Ensure live restore is Enabled (Automated)"
      audit: |
        crio info --format 'LiveRestoreEnabled={{ .LiveRestoreEnabled }}'
        grep live-restore $crio-config-file | tr -d ","
      tests:
        bin_op: or
        test_items:
        - flag: "LiveRestoreEnabled"
          compare:
            op: eq
            value: true
          set: true
        - flag: "live-restore"
          compare:
            op: eq
            value: true
          set: true
      remediation: |
        Run the CRI-O in daemon mode and pass --live-restore as an argument.
        For Example,
        crio --live-restore
      scored: true

    - id: 2.16
      description: "Ensure Userland Proxy is Disabled (Automated)"
      audit: |
        ps -ef | grep crio
        grep userland-proxy $crio-config-file | tr -d ","
      tests:
        test_items:
        - flag: "userland-proxy"
          compare:
            op: eq
            value: "false"
          set: true
      remediation: |
        You should run the CRI-O daemon as below:
        crio --userland-proxy=false
      scored: true

    - id: 2.17
      description: "Ensure that a daemon-wide custom seccomp profile is applied if appropriate (Manual)"
      audit: "crio info --format '{{ .SecurityOptions }}'"
      type: manual
      tests:
        test_items:
        - flag: "profile"
          compare:
            op: nothave
            value: "default"
          set: true
      remediation: |
        By default, CRI-O's default seccomp profile is applied. If this is adequate for your
        environment, no action is necessary. Alternatively, if you choose to apply your own
        seccomp profile, use the --seccomp-profile flag at daemon start or put it in the daemon
        runtime parameters file.
        crio --seccomp-profile </path/to/seccomp/profile>
      scored: false

    - id: 2.18
      description: "Ensure that experimental features are not implemented in production (Automated)"
      audit: "crio version --format 'experimental={{ .Server.Experimental }}'"
      tests:
        test_items:
        - flag: "experimental"
          compare:
            op: eq
            value: false
          set: true
      remediation: |
        You should not pass --experimental as a runtime parameter to the CRI-O daemon on
        production systems.
      scored: true

  - id: 3
    description: "CRI-O daemon configuration files"
    checks:
    - id: 3.1
      description: "Ensure that crio.service file ownership is set to root:root (Automated)"
      audit: systemctl show -p FragmentPath crio.service | cut -d= -f2 | xargs stat -c "%N %U:%G"
      tests:
        test_items:
        - flag: "root:root"
          set: true
      remediation: |
        Step 1: Find out the file location:
        systemctl show -p FragmentPath crio.service
        Step 2: If the file does not exist, this recommendation is not applicable. If the file does exists,
        you should execute the below command with the correct file path to set the ownership and group
        ownership and group for the file to root .
        For example,
        chown root:root /usr/lib/systemd/system/crio.service
      scored: true

    - id: 3.2
      description: "Ensure that crio.service file permissions are appropriately set (Automated)"
      audit: systemctl show -p FragmentPath crio.service | cut -d= -f2 | xargs stat -c "%N permissions=%a"
      tests:
        test_items:
        - flag: "permissions"
          compare:
            op: bitmask
            value: "644"
          set: true
      remediation: |
        Step 1: Find out the file location:
        systemctl show -p FragmentPath crio.service
        Step 2: If the file does not exist, this recommendation is not applicable. If the file exists,
        execute the below command with the correct file path to set the file permissions to 644 .
        For example,
        chmod 644 /usr/lib/systemd/system/crio.service
      scored: true

    - id: 3.3
      description: "Ensure that crio.socket file ownership is set to root:root (Automated)"
      audit: systemctl show -p FragmentPath crio.socket | cut -d= -f2 | xargs stat -c "%N %U:%G"
      tests:
        test_items:
        - flag: "root:root"
          set: true
      remediation: |
        Step 1: Find out the file location:
        systemctl show -p FragmentPath crio.socket
        Step 2: If the file does not exist, this recommendation is not applicable. If the file exists,
        execute the command below, including the correct file path to set the ownership and group
        ownership for the file to root .
        For example,
        chown root:root /usr/lib/systemd/system/crio.socket
      scored: true

    - id: 3.4
      description: "Ensure that crio.socket file permissions are set to 644 or more restrictive (Automated)"
      audit: systemctl show -p FragmentPath crio.socket | cut -d= -f2 | xargs stat -c "%N permissions=%a"
      tests:
        test_items:
        - flag: "permissions"
          compare:
            op: bitmask
            value: "644"
          set: true
      remediation: "Step 1: Find out the file location:\nsystemctl show -p FragmentPath crio.socket\nStep 2: If the file does not exist, this recommendation is not applicable. If the file does exists, you\nshould execute the command below, including the correct file path in order to verify that \nthe file permissions are set to 644 or more restrictively.      \nFor example,\nchmod 644 /usr/lib/systemd/system/crio.socket\n"
      scored: true

    - id: 3.5
      description: "Ensure that /etc/crio directory ownership is set to root:root (Automated)"
      audit: stat -c "%N %U:%G" /etc/crio
      tests:
        test_items:
        - flag: "root:root"
          set: true
      remediation: |
        To resolve this issue you should run the following command:
        chown root:root /etc/crio
        This sets the ownership and group-ownership for the directory to root .
      scored: true

    - id: 3.6
      description: "Ensure that /etc/crio directory permissions are set to 755 or more restrictive (Automated)"
      audit: stat -c "%N permissions=%a" /etc/crio
      tests:
        test_items:
        - flag: "permissions"
          compare:
            op: bitmask
            value: "755"
          set: true
      remediation: |
        You should run the following command:
        chmod 755 /etc/crio
        This sets the permissions for the directory to 755 .
      scored: true

    - id: 3.7
      description: "Ensure that registry certificate file ownership is set to root:root (Automated)"
      audit: stat -c "%N %U:%G" /etc/crio/crio.d/*
      use_multiple_values: true
      tests:
        test_items:
        - flag: "root:root"
          set: true
      remediation: |
        The following command could be executed:
        chown root:root /etc/crio/crio.d/<registry-name>/*
        This would set the individual ownership and group ownership for the registry certificate
        files to root.
      scored: true

    - id: 3.8
      description: "Ensure that registry certificate file permissions are set to 444 or more restrictive (Automated)"
      audit: stat -c "%N permissions=%a" /etc/crio/crio.d/*
      use_multiple_values: true
      tests:
        test_items:
        - flag: "permissions"
          compare:
            op: bitmask
            value: "444"
          set: true
      remediation: |
        You should execute the following command:
        chmod 444 /etc/crio/crio.d/<registry-name>/*
        This would set the permissions for registry certificate files to 444 .
      scored: true

    - id: 3.9
      description: "Ensure that TLS CA certificate file ownership is set to root:root (Automated)"
      type: manual
      remediation: |
        You should execute the following command:
        chown root:root <path to TLS CA certificate file>
        This sets the individual ownership and group ownership for the TLS CA certificate file to root.
      scored: true

    - id: 3.10
      description: "Ensure that TLS CA certificate file permissions are set to 444 or more restrictive (Automated)"
      type: manual
      remediation: |
        You should execute the following command: chmod 444 <path to TLS CA certificate file>
        chmod 444 <path to TLS CA certificate file>
        This sets the file permissions on the TLS CA file to 444.
      scored: true

    - id: 3.11
      description: "Ensure that CRI-O server certificate file ownership is set to root:root (Automated)"
      type: manual
      remediation: |
        You should run the following command:
        chown root:root <path to CRI-O server certificate file>
        This sets the individual ownership and the group ownership for the CRI-O server
        certificate file to root.
      scored: true

    - id: 3.12
      description: "Ensure that CRI-O server certificate file permissions are set to 444 or more restrictive (Automated)"
      type: manual
      remediation: |
        You should execute the command below:
        chmod 444 <path to CRI-O server certificate file>
        This sets the file permissions of the CRI-O server certificate file to 444 .
      scored: true

    - id: 3.13
      description: "Ensure that CRI-O server certificate key file ownership is set to root:root (Automated)"
      type: manual
      remediation: |
        You should execute the following command:
        chown root:root <path to CRI-O server certificate key file>
        This sets the individual ownership and group ownership for the CRI-O server certificate
        key file to root.
      scored: true

    - id: 3.14
      description: "Ensure that the CRI-O server certificate key file permissions are set to 400 (Automated)"
      type: manual
      remediation: |
        You should execute the following command:
        chmod 400 <path to CRI-O server certificate key file>
        This sets the CRI-O server certificate key file permissions to 400 .
      scored: true

  - id: 3.15
    description: "Ensure that CRI-O socket file ownership is set to root:docker (Automated)"
    audit: stat -c "%N %U:%G" /var/run/crio/crio.sock
    tests:
      test_items:
      - flag: "root:docker"
        set: true
    remediation: |
      You should execute the following command:
      chown root:docker /var/run/crio/crio.sock
      This would set the ownership to root and group-ownership to docker for default CRI-O
      socket file.
    scored: true

  - id: 3.16
    description: "Ensure that CRI-O socket file permissions are set to 660 or more restrictive (Automated)"
    audit: stat -c "%N permissions=%a" /var/run/crio/crio.sock
    tests:
      test_items:
      - flag: "permissions"
        compare:
          op: bitmask
          value: "660"
        set: true
    remediation: |
      You should execute the command below.
      chmod 660 /var/run/crio/crio.sock
      This sets the file permissions of the CRI-O socket file to 660.
    scored: true

  - id: 3.17
    description: "Ensure that crio.conf file ownership is set to root:root (Automated)"
    audit: stat -c "%N %U:%G" /etc/crio/crio.conf
    tests:
      test_items:
      - flag: "root:root"
        set: true
    remediation: |
      You should execute the command below:
      chown root:root /etc/crio/crio.conf
      This sets the ownership and group-ownership for the file to root .
    scored: true

  - id: 3.18
    description: "Ensure that crio.conf file permissions are set to 644 or more restrictive (Automated)"
    audit: stat -c "%N permissions=%a" /etc/crio/crio.conf
    tests:
      test_items:
      - flag: "permissions"
        compare:
          op: bitmask
          value: "644"
        set: true
    remediation: |
      You should execute the command below
      chmod 644 /etc/crio/crio.conf
      This sets the file permissions for this file to 644.
    scored: true

  - id: 3.19
    description: "Ensure that /etc/default/crio file ownership is set to root:root (Automated)"
    audit: stat -c "%N %U:%G" /etc/default/crio
    tests:
      test_items:
      - flag: "root:root"
        set: true
    remediation: |
      You should execute the following command
      chown root:root /etc/default/crio
      This sets the ownership and group-ownership for the file to root.
    scored: true

  - id: 3.20
    description: "Ensure that /etc/sysconfig/crio file permissions are set to 644 or more restrictive (Automated)"
    audit: stat -c "%N permissions=%a" /etc/sysconfig/crio
    tests:
      test_items:
      - flag: "permissions"
        compare:
          op: bitmask
          value: "644"
        set: true
    remediation: |
      You should execute the following command:
      chmod 644 /etc/sysconfig/crio
      This sets the file permissions for this file to 644.
    scored: true

  - id: 3.21
    description: "Ensure that /etc/sysconfig/crio file ownership is set to root:root (Automated)"
    audit: stat -c "%N %U:%G" /etc/sysconfig/crio
    tests:
      test_items:
      - flag: "root:root"
        set: true
    remediation: |
      You should execute the following command
      chown root:root /etc/sysconfig/crio
      This  sets the ownership and group-ownership for the file to root .
    scored: true

  - id: 3.22
    description: "Ensure that /etc/default/crio file permissions are set to 644 or more restrictive (Automated)"
    audit: stat -c "%N permissions=%a" /etc/default/crio
    tests:
      test_items:
      - flag: "permissions"
        compare:
          op: bitmask
          value: "644"
        set: true
    remediation: |
      You should execute the following command:
      chmod 644 /etc/default/crio
      This sets the file permissions for this file to 644.
    scored: true

  - id: 3.23
    description: "Ensure that Containerd socket file ownership is set to root:root (Automated)"
    audit: stat -c "%N %U:%G" /run/containerd/containerd.sock
    tests:
      test_items:
      - flag: "root:root"
        set: true
    remediation: |
      You should execute the following command
      chown root:root /run/containerd/containerd.sock
      This sets the ownership to root and group ownership to root for the default Containerd socket file.
    scored: true

  - id: 3.24
    description: "Ensure that Containerd socket file permissions are set to 660 or more restrictive (Automated)"
    audit: stat -c "%N permissions=%a" /run/containerd/containerd.sock
    tests:
      test_items:
      - flag: "permissions"
        compare:
          op: bitmask
          value: "660"
        set: true
    remediation: |
      You should execute the following command:
      chmod 660 /run/containerd/containerd.sock
      This sets the file permissions for this file to 660.
    scored: true

  - id: 4.1
    description: "Ensure that a user for the container has been created (Automated)"
    audit: "crictl ps -q | xargs -I{} crictl exec {} cat /proc/1/status | grep '^Uid:' | awk '{print \"User=\"$3}'"
    use_multiple_values: true
    tests:
      bin_op: and
      test_items:
      - flag: "User"
        compare:
          op: nothave
          value: "root"
        set: true
      - flag: "User"
        compare:
          op: noteq
          value: ""
        set: true
      - flag: "User"
        compare:
          op: noteq
          value: "1"
        set: true
      - flag: "User"
        compare:
          op: noteq
          value: "0"
        set: true
    remediation: |
      You should ensure that the Dockerfile for each container image contains the information below:
      USER <username or ID>
      In this case, the user name or ID refers to the user that was found in the container base
      image. If there is no specific user created in the container base image, then make use of the
      useradd command to add a specific user before the USER instruction in the Dockerfile.
      For example, add the below lines in the Dockerfile to create a user in the container:
      RUN useradd -d /home/username -m -s /bin/bash username
      USER username
      Note: If there are users in the image that are not needed, you should consider deleting
      them. After deleting those users, commit the image and then generate new instances of the
      containers.
      Alternatively, if it is not possible to set the USER directive in the Dockerfile, a script running
      as part of the CMD or ENTRYPOINT sections of the Dockerfile should be used to ensure that
      the container process switches to a non-root user.
    scored: true

  - id: 4.2
    description: "Ensure that containers use only trusted base images (Manual)"
    type: manual
    remediation: |
      The following procedures are useful for establishing trust for a specific image.
      - Configure and use CRI-O Content trust.
      - View the history of each CRI-O image to evaluate its risk, dependent on the
        sensitivity of the application you wish to deploy using it.
      - Scan CRI-O images for vulnerabilities at regular intervals.
    scored: false

  - id: 4.3
    description: "Ensure that unnecessary packages are not installed in the container (Manual)"
    type: manual
    remediation: |
      You should not install anything within the container that is not required.
      You should consider using a minimal base image rather than the standard
      Red Hat/CentOS/Debian images if you can. Some of the options available include BusyBox
      and Alpine.
      Not only can this trim your image size considerably, but there would also be fewer pieces of
      software that could contain vectors for attack.
    scored: false

  - id: 4.4
    description: "Ensure images are scanned and rebuilt to include security patches (Manual)"
    type: manual
    remediation: |
      Images should be re-built ensuring that the latest version of the base images is used to
      keep the operating system patch level at an appropriate level. Once the images have been
      re-built, containers should be re-started making use of the updated images.
    scored: false

  - id: 4.5
    description: "Ensure Content trust for CRI-O is Enabled (Automated)"
    audit: echo CRICTL_CONTENT_TRUST=$CRICTL_CONTENT_TRUST
    tests:
      test_items:
      - flag: CRICTL_CONTENT_TRUST
        compare:
          op: eq
          value: 1
        set: true
    remediation: "To enable content trust in a bash shell, enter the following command:\nexport CRICTL_CONTENT_TRUST=1\nAlternatively, you could set this environment variable in your profile file so that content \ntrust is enabled on every login.\n"
    scored: true

  - id: 4.6
    description: "Ensure HEALTHCHECK instructions have been added to the container images (Automated)"
    type: manual
    remediation: |
      You should follow the CRI-O documentation and rebuild your container images to include
      the HEALTHCHECK instruction.
    scored: true

  - id: 4.7
    description: "Ensure update instructions are not used alone in the Dockerfile (Manual)"
    type: manual
    remediation: |
      You should use update instructions together with install instructions and version pinning
      for packages while installing them. This prevents caching and forces the extraction of the
      required versions.
      Alternatively, you could use the --no-cache flag during the cri build process to avoid
      using cached layers.
    scored: false

  - id: 4.8
    description: "Ensure setuid and setgid permissions are removed (Manual)"
    type: manual
    remediation: |
      You should allow setuid and setgid permissions only on executables that require them.
      You could remove these permissions at build time by adding the following command in
      your Dockerfile, preferably towards the end of the Dockerfile:
      RUN find / -perm /6000 -type f -exec chmod a-s {} \; || true
    scored: false

  - id: 4.9
    description: "Ensure COPY is used instead of ADD in Dockerfile (Manual)"
    type: manual
    remediation: |
      You should use COPY rather than ADD instructions in Dockerfiles.
    scored: false

  - id: 4.10
    description: "Ensure secrets are not stored in Dockerfiles (Manual)"
    type: manual
    remediation: "Do not store any kind of secrets within Dockerfiles. Where secrets are required during the \nbuild process, make use of a secrets management tool, such as the buildkit builder included \nwith CRI-O.\n"
    scored: false

  - id: 4.11
    description: "Ensure only verified packages are Installed (Manual)"
    type: manual
    remediation: "You should use a secure package distribution mechanism of your choice to ensure the \nauthenticity of software packages.\n"
    scored: false

  - id: 5.1
    description: "Ensure that, if applicable, an AppArmor Profile is enabled (Automated)"
    type: manual
    remediation: |
      If AppArmor is applicable for your Linux OS, you should enable it.
            1. Verify if AppArmor is installed. If not, install it.
            2. Create or import an AppArmor profile for CRI-O containers.
            3. Put this profile in enforcing mode.
            4. Start your CRI-O container using the customized AppArmor profile. For example,
      crictl run --security-opt="apparmor:PROFILENAME" <ImageID>
      Alternatively, CRI-O's default AppArmor policy can be used.
    scored: true

  - id: 5.2
    description: "Ensure that, if applicable, SELinux security options are set(Automated)"
    type: manual
    remediation: |
      If SELinux is applicable for your Linux OS, you should use it.
            1. Set the SELinux State.
            2. Set the SELinux Policy.
            3. Create or import a SELinux policy template for CRI-O containers.
            4. Start CRI-O in daemon mode with SELinux enabled. For example,
      crictl --selinux-enabled
            5. Start your CRI-O container using the security options. For example,
      crictl run --security-opt label=level:TopSecret <ImageID>
    scored: true

  - id: 5.3
    description: "Ensure that Linux Kernel capabilities are restricted within containers (Automated)"
    type: manual
    remediation: |
      You should execute the command below to add required capabilities:
      crictl run --cap-add={"Capability 1","Capability 2"} <Run arguments>
      <Container Image Name or ID> <Command>
      You should execute the command below to remove unneeded capabilities:
      crictl run --cap-drop={"Capability 1","Capability 2"} <Run arguments>
      <Container Image Name or ID> <Command>
      Alternatively, you could remove all the currently configured capabilities and then restore
      only the ones you specifically use:
      crictl run --cap-drop=all --cap-add={"Capability 1","Capability 2"} <Run
      arguments> <Container Image Name or ID> <Command>
    scored: true

  - id: 5.4
    description: "Ensure that privileged containers are not used (Automated)"
    audit: crictl ps --quiet --all | xargs crictl inspect --output json | jq '.info.Config.Privileged'
    use_multiple_values: true
    tests:
      test_items:
      - flag: "true"
        set: false
    remediation: |
      You should not run containers with the --privileged flag.
      For example, do not start a container using the command below:
      crictl run --interactive --tty --privileged <ImageID> /bin/bash
    scored: true

  - id: 5.5
    description: "Ensure sensitive host system directories are not mounted on containers (Automated)"
    audit: crictl ps --quiet --all | xargs crictl inspect --output json | jq '.info.Mounts'
    use_multiple_values: true
    tests:
      test_items:
      - flag: "Source:/ Destination"
        set: false
      - flag: "Source:/boot Destination"
        set: false
      - flag: "Source:/dev Destination"
        set: false
      - flag: "Source:/etc Destination"
        set: false
      - flag: "Source:/lib Destination"
        set: false
      - flag: "Source:/proc Destination"
        set: false
      - flag: "Source:/sys Destination"
        set: false
      - flag: "Source:/usr Destination"
        set: false
    remediation: "You should not mount directories that are security-sensitive on the host within \ncontainers, especially in read-write mode.\n"
    scored: true

  - id: 5.6
    description: "Ensure sshd is not run within containers (Automated)"
    audit: crictl ps --quiet --all | xargs crictl inspect --output json | jq '.info.Config.Cmd[] | contains("sshd")'
    use_multiple_values: true
    tests:
      test_items:
      - flag: "true"
        set: false
    remediation: |
      You should uninstall the SSH daemon from the container and use `crictl exec` to enter a
      container on the remote host.
      For example:
      crictl exec -i -t $INSTANCE_ID sh
      OR
      crictl attach $INSTANCE_ID
    scored: true

  - id: 5.7
    description: "Ensure privileged ports are not mapped within containers (Automated)"
    audit: crictl ps --quiet --all | xargs crictl inspect --output json | jq '.info.HostConfig.PortBindings | to_entries | map(.value.host_ip == "" and (.value.host_port | tonumber) < 1024) | any'
    use_multiple_values: true
    tests:
      test_items:
      - flag: "true"
        set: false
    remediation: |
      You should not map container ports to privileged host ports when starting a container. Ensure
      that there is no such container-to-host privileged port mapping declarations in the CRI-O configuration.
    scored: true

  - id: 5.8
    description: "Ensure that only needed ports are open on the container (Manual)"
    type: manual
    remediation: |
      You should ensure that the Dockerfile for each container image only exposes needed ports.
      Explicitly define the ports that you need for a particular container instance using the `-p` or
      `--publish` flag.
      For example:
      crictl run --interactive --tty -p 5000:5000 -p 5001:5001 -p 5002:5002 <image_id> /bin/bash
    scored: false

  - id: 5.9
    description: "Ensure that the host's network namespace is not shared (Automated)"
    audit: crictl ps --quiet --all | xargs crictl inspect --output json | jq '.info.HostConfig.NetworkMode == "host"'
    use_multiple_values: true
    tests:
      test_items:
      - flag: "true"
        set: false
    remediation: |
      You should not pass the `--net=host` option when starting any container.
    scored: true

  - id: 5.10
    description: "Ensure that the memory usage for the container is limited (Automated)"
    audit: crictl ps --quiet --all | xargs crictl inspect --output json | jq '.info.HostConfig.Memory'
    use_multiple_values: true
    tests:
      test_items:
      - flag: "Memory"
        compare:
          op: gt
          value: 0
        set: true
    remediation: |
      Run the container with only as much memory as it requires by using the `--memory` argument.
      For example:
      crictl run --interactive --tty --memory 256m <image_id> /bin/bash
    scored: true

  - id: 5.11
    description: "Ensure that CPU priority is set appropriately on the container (Automated)"
    audit: crictl ps --quiet --all | xargs crictl inspect --output json | jq '.info.HostConfig.CpuShares'
    use_multiple_values: true
    tests:
      test_items:
      - flag: "CpuShares"
        compare:
          op: gt
          value: 0
        set: true
      - flag: "CpuShares"
        compare:
          op: lt
          value: 1024
        set: true
    remediation: |
      Manage the CPU runtime between your containers by starting the container using the
      `--cpu-shares` argument.
      For example:
      crictl run --interactive --tty --cpu-shares 512 <image_id> /bin/bash
    scored: true

  - id: 5.12
    description: "Ensure that the container's root filesystem is mounted as read-only (Automated)"
    audit: crictl ps --quiet --all | xargs crictl inspect --output json | jq '.info.HostConfig.ReadonlyRootfs == false'
    use_multiple_values: true
    tests:
      test_items:
      - flag: "ReadonlyRootfs=false"
        set: false
    remediation: |
      Add the `--read-only` flag at a container's runtime to enforce the container's root filesystem
      being mounted as read-only.
      For example:
      crictl run --detach --read-only <image_id> /bin/bash
    scored: true

  - id: 5.13
    description: "Ensure that incoming container traffic is bound to a specific host interface (Automated)"
    audit: crictl ps --quiet | xargs crictl inspect --output json | jq '.info.HostConfig.PortBindings | to_entries | map(.value.host_ip == "0.0.0.0") | any'
    use_multiple_values: true
    tests:
      test_items:
      - flag: "true"
        set: false
    remediation: |
      Bind the container port to a specific host interface on the desired host port.
      For example:
      crictl run --detach --publish 10.2.3.4:49153:80 nginx
    scored: true

  - id: 5.14
    description: "Ensure that the 'on-failure' container restart policy is set to '5' (Automated)"
    audit: crictl ps --quiet --all | xargs crictl inspect --output json | jq '.info.HostConfig.RestartPolicy.Name != "always" and .info.HostConfig.RestartPolicy.Name != "" and .info.HostConfig.RestartPolicy.MaximumRetryCount == 5'
    use_multiple_values: true
    tests:
      test_items:
      - flag: "RestartPolicyName"
        compare:
          op: noteq
          value: "always"
        set: true
      - flag: "RestartPolicyName"
        compare:
          op: noteq
          value: ""
        set: true
      - flag: "RestartPolicyName"
        compare:
          op: eq
          value: "no"
        set: true
    remediation: |
      Set the container restart policy to 'on-failure:5'.
      For example:
      crictl run --detach --restart on-failure:5 <image_id>
    scored: true

  - id: 5.15
    description: "Ensure that the host's process namespace is not shared (Automated)"
    audit: crictl ps --quiet --all | xargs crictl inspect --output json | jq '.info.HostConfig.PidMode == "host"'
    use_multiple_values: true
    tests:
      test_items:
      - flag: "true"
        set: false
    remediation: |
      Do not start a container with the `--pid=host` argument.
      For example:
      crictl run --interactive --tty --pid=host <image_id> /bin/bash
    scored: true

  - id: 5.16
    description: "Ensure that the host's IPC namespace is not shared (Automated)"
    audit: crictl ps --quiet --all | xargs crictl inspect --output json | jq '.info.HostConfig.IpcMode == "host"'
    use_multiple_values: true
    tests:
      test_items:
      - flag: "true"
        set: false
    remediation: |
      Do not start a container with the `--ipc=host` argument.
      For example:
      crictl run --interactive --tty --ipc=host <image_id> /bin/bash
    scored: true

  - id: 5.17
    description: "Ensure that host devices are not directly exposed to containers (Manual)"
    type: manual
    remediation: |
      Do not directly expose host devices to containers. If needed, use granular permissions
      appropriate to your devices.
    scored: false

  - id: 5.18
    description: "Ensure that the default ulimit is overwritten at runtime, only if needed (Manual)"
    type: manual
    remediation: |
      You should only override the default ulimit settings if needed in a specific case.
      For example, to override default ulimit settings start a container as below:
      crictl run --ulimit nofile=1024:1024 --interactive --tty <image_id> /bin/bash
    scored: true

  - id: 5.19
    description: "Ensure mount propagation mode is not set to shared (Automated)"
    audit: crictl ps --quiet --all | xargs crictl inspect --output json | jq '.info.Mounts | map(.Propagation == "rshared") | any'
    use_multiple_values: true
    tests:
      test_items:
      - flag: "true"
        set: false
    remediation: |
      Do not mount volumes in shared mode propagation.
      For example, do not start container as below:
      crictl run <Run arguments> --mount type=bind,source=/hostPath,target=/containerPath,bind-propagation=rshared <Container Image Name or ID> <Command>
    scored: true

  - id: 5.20
    description: "Ensure that the host's UTS namespace is not shared (Automated)"
    audit: crictl ps --quiet --all | xargs crictl inspect --output json | jq '.info.HostConfig.UTSMode == "host"'
    use_multiple_values: true
    tests:
      test_items:
      - flag: "UTSMode=host"
        set: false
    remediation: |
      You should not start a container with the --uts=host argument.
      For example, do not start a container as below:
      crictl run --rm --interactive --tty --uts=host <image_id>
    scored: true

  - id: 5.21
    description: "Ensure the default seccomp profile is not Disabled (Automated)"
    audit: crictl ps --quiet --all | xargs crictl inspect --output json | jq '.info.HostConfig.SecurityOpt | map(test(". == \"seccomp:unconfined\"") | not) | all'
    use_multiple_values: true
    tests:
      test_items:
      - flag: "true"
        set: false
    remediation: |
      By default, seccomp profiles are enabled. You do not need to do anything unless you want
      to modify and use the modified seccomp profile.
    scored: true

  - id: 5.22
    description: "Ensure that docker exec commands are not used with the privileged option (Automated)"
    audit: ausearch -if $audit-log -k docker | grep exec | grep privileged
    tests:
      test_items:
      - flag: "privileged"
        set: false
    remediation: |
      If audit rule for docker file not set
      Add the line as below in /etc/audit/audit.rules file:
      -w /usr/bin/docker -p rwxa -k docker-daemon
      Then, restart the audit daemon.
      service auditd restart
      You should not use the --privileged option in docker exec commands.
    scored: true

  - id: 5.23
    description: "Ensure that docker exec commands are not used with the user=root option (Manual)"
    audit: ausearch -if $audit-log -k docker | grep exec | grep user
    tests:
      test_items:
      - flag: "user=root"
        set: true
    remediation: |
      If audit rule for docker file not set
      Add the line as below in /etc/audit/audit.rules file:
      -w /usr/bin/docker -p rwxa -k docker-daemon
      Then, restart the audit daemon.
      service auditd restart
      You should not use the --user=root option in docker exec commands.
    scored: true

  - id: 5.24
    description: "Ensure cgroup usage is confirmed (Automated)"
    type: manual
    remediation: "You should not use the --cgroup-parent option within the crictl run command unless \nstrictly required.\n"
    scored: true

  - id: 5.25
    description: "Ensure that the container is restricted from acquiring additional privileges (Automated)"
    audit: crictl ps --quiet --all | xargs crictl inspect --output json | jq '.info.HostConfig.SecurityOpt | map(test(". == \"no-new-privileges\"") | all) | all'
    use_multiple_values: true
    tests:
      test_items:
      - flag: "true"
        set: true
    remediation: "You should start your container with the options below: \ncrictl run --rm -it --security-opt=no-new-privileges <image_id> /bin/bash\n"
    scored: true

  - id: 5.26
    description: "Ensure that container health is checked at runtime (Automated)"
    type: manual
    remediation: |
      You should run the container using the --health-cmd parameter.
      For example,
      crictl run --detach --health-cmd='stat /etc/passwd || exit 1' <image_id>
    scored: true

  - id: 5.27
    description: "Ensure that Docker commands always make use of the latest version of their image (Manual)"
    type: manual
    remediation: |
      You should use proper version pinning mechanisms (the "latest" tag which is assigned by
      default is still vulnerable to caching attacks) to avoid extracting cached older versions.
      Version pinning mechanisms should be used for base images, packages, and entire images.
      You can customize version pinning rules according to your requirements.
    scored: false

  - id: 5.28
    description: "Ensure that the PIDs cgroup limit is used (Automated)"
    audit: crictl ps --quiet --all | xargs crictl inspect --output json | jq '.info.HostConfig.PidsLimit | map(test(". > 0") | all) | all'
    use_multiple_values: true
    tests:
      test_items:
      - flag: "true"
        set: true
    remediation: |
      Use --pids-limit flag with an appropriate value when launching the container.
      For example,
      crictl run --detach --pids-limit 100 <image_id>
      In the above example, the number of processes allowed to run at any given time is set to
      100. After a limit of 100 concurrently running processes is reached, CRI-O would restrict
      any new process creation.
    scored: true

  - id: 5.29
    description: "Ensure that Docker's default bridge docker0 is not used (Manual)"
    audit: crictl info --output json | jq '.info["config"]["network"] != "docker0"'
    tests:
      test_items:
      - flag: "true"
        set: true
    remediation: |
      You should follow the CRI-O documentation and set up a user-defined network. All the
      containers should be run in this network.
    scored: false

  - id: 5.30
    description: "Ensure that the host's user namespaces is not shared (Automated)"
    audit: crictl ps --quiet --all | xargs crictl inspect --output json | jq '.info.HostConfig.UsernsMode | map(test(". == \"host\"") | all) | all'
    tests:
      test_items:
      - flag: "true"
        set: true
    remediation: |
      You should not share user namespaces between host and containers.
      For example, you should not run the command below:
      crictl run --rm -it --userns=host <image_id> /bin/bash
    scored: true

  - id: 5.31
    description: "Ensure that the Docker socket is not mounted inside any containers (Automated)"
    audit: crictl ps --quiet --all | xargs crictl inspect --output json | jq '.info.Mounts | map(.Destination == "/var/run/docker.sock") | any'
    tests:
      test_items:
      - flag: "true"
        set: false
    remediation: |
      You should ensure that no containers mount docker.sock as a volume.
    scored: true

  - id: 6
    description: "Docker Security Operations"
    checks:
    - id: 6.1
      description: "Ensure that image sprawl is avoided (Manual)"
      type: manual
      remediation: |
        You should keep only the images that you actually need and establish a workflow to
        remove old or stale images from the host. Additionally, you should use features such as
        pull-by-digest to get specific images from the registry.
        You can follow the steps below to find unused images on the system so they can be deleted.
        Step 1 Make a list of all image IDs that are currently instantiated by executing the
        command below:
        crictl images --quiet | xargs crictl inspect --output json | jq '.info.id + ": Image=" + .info.config.image'
        Step 2: List all the images present on the system by executing the command below:
        crictl images
        Step 3: Compare the list of image IDs from Step 1 and Step 2 and look for images that are
        currently not in use. If any unused or old images are found, discuss with the system
        administrator the need to keep such images on the system. If images are no longer needed
        they should be deleted.
      scored: false

    - id: 6.2
      description: "Ensure that container sprawl is avoided (Manual)"
      type: manual
      remediation: |
        You should periodically check your container inventory on each host and clean up
        containers which are not in active use with the command below:
        crictl ps --quiet --all | xargs crictl rm
      scored: false

  - id: 7
    description: "Docker Swarm Configuration"
    constraints:
      cri-o-swarm:
      - active
    checks:
    - id: 7.1
      description: "Ensure swarm mode is not Enabled, if not needed (Automated)"
      type: manual
      remediation: |
        If swarm mode has been enabled on a system in error, you should run the command below:
        crictl swarm leave
      scored: true

    - id: 7.2
      description: "Ensure that the minimum number of manager nodes have been created in a swarm (Automated)"
      type: manual
      remediation: |
        If an excessive number of managers is configured, the excess nodes can be demoted to
        workers using the following command:
        crictl node demote <ID>
        Where is the node ID value of the manager to be demoted.
      scored: true

    - id: 7.3
      description: "Ensure that swarm services are bound to a specific host interface (Automated)"
      audit: ss -lp | grep -iE ':2377|:7946'
      tests:
        test_items:
        - flag: "0.0.0.0"
          set: false
      remediation: |
        Resolving this issues requires re-initialization of the swarm, specifying a specific interface
        for the --listen-addr parameter.
      scored: true

    - id: 7.4
      description: "Ensure that all Docker swarm overlay networks are encrypted (Automated)"
      audit: crictl plugin ls --quiet --filter type=network | xargs -r crictl plugin inspect --format '{{ .Name }} {{ .Options }}'
      use_multiple_values: true
      tests:
        test_items:
        - flag: "encrypted"
          set: true
      remediation: |
        Create overlay network with --opt encrypted flag.
      scored: true

    - id: 7.5
      description: "Ensure that CRI-O's secret management commands are used for managing secrets in a swarm cluster (Manual)"
      type: manual
      remediation: |
        You should follow the CRI-O secret documentation and use it to manage secrets effectively.
      scored: true

    - id: 7.6
      description: "Ensure that swarm manager is run in auto-lock mode (Automated)"
      audit: "crictl info --output json | jq '.info.swarm.encryptionConfig.autoLockManagers == true'"
      tests:
        test_items:
        - flag: "true"
          set: true
      remediation: "If you are initializing a swarm, use the command below.\ncrictl swarm init --autolock\nIf you want to set --autolock on an existing swarm manager node, use the following \ncommand.\ncrictl swarm update --autolock\n"
      scored: true

    - id: 7.7
      description: "Ensure that the swarm manager auto-lock key is rotated periodically (Manual)"
      type: manual
      remediation: |
        You should run the command below to rotate the keys.
        crictl swarm unlock-key --rotate
        Additionally, to facilitate auditing of this recommendation, you should maintain key
        rotation records and ensure that you establish a pre-defined frequency for key rotation.
      scored: false

    - id: 7.8
      description: "Ensure that node certificates are rotated as appropriate (Manual)"
      type: manual
      remediation: |
        You should run the command to set the desired expiry time on the node certificate.
        For example,
        crictl swarm update --cert-expiry 48h
      scored: false

    - id: 7.9
      description: "Ensure that CA certificates are rotated as appropriate (Manual)"
      type: manual
      remediation: |
        You should run the command below to rotate a certificate.
        crictl swarm ca --rotate
      scored: false

    - id: 7.10
      description: "Ensure that management plane traffic is separated from data plane traffic (Manual)"
      type: manual
      remediation: |
        You should run the command below on each swarm node and ensure that the management
        plane address is different from the data plane address.
        crictl swarm init --advertise-addr=192.168.0.1 --data-path-addr=17.1.0.3
      scored: false
